{"type":"deployment","id":"CrossChainGovernanceReceiver","batch":"CCIP","deploymentAddress":"0x9c3C2983dbeb7e100904187EE2456816a462834d","constructorArgs":["0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59"],"to":"0x4e59b44847b379578588920ca78fbf26c0b4956c","value":"0","data":"0x00000000000000000000000000000000000000000000000050494e47504f4e4760a03461008e57601f61051538819003918201601f19168301916001600160401b038311848410176100935780849260209460405283398101031261008e57516001600160a01b03811680820361008e57156100755760805260405161046b90816100aa82396080518181816059015260cf0152f35b6040516335fdcccd60e21b815260006004820152602490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060408181526004918236101561001657600080fd5b600092833560e01c91826301ffc9a7146103255750816385572ffb1461008c575063b0f479a11461004657600080fd5b34610088578160031936011261008857517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b91905034610321576020906003199282843601126102795780359067ffffffffffffffff948583116102755760a090833603011261027d576001600160a01b03907f00000000000000000000000000000000000000000000000000000000000000008216330361030a5783519060a08201828110888211176102f7578552838101358252602492602485013588811681036102ef578784015260448501358881116102ef57610140908336918801016103d0565b8684015260648501358881116102ef5761015f908336918801016103d0565b94606084019586526084810135908982116102f3570191366023840112156102ef5780830135918983116102dc5761019b898460051b01610378565b9560248a88868152019460061b860101943686116102d857602401935b858510610281575050505050506080015251928351840193838181870196031261027d578381015191821161027d570183603f82011215610279578281015193610209610204866103b4565b610378565b9185835284830191848783010111610275577fa7b4f710e7636ed7b4f98085b7004cd898d5cafa9d5d3e19e7a435283d3a2c4d9582856102499301610412565b6102658351948593818552519283809286015285850190610412565b601f01601f19168101030190a180f35b8680fd5b8480fd5b8580fd5b89853603126102d857895190818b018d8111838210176102c6578b5285359084821682036102c257828d928d945282880135838201528152019401936101b8565b8e80fd5b634e487b7160e01b8f5260418652838ffd5b8c80fd5b634e487b7160e01b8b526041825260248bfd5b8980fd5b8a80fd5b634e487b7160e01b895260418252602489fd5b6024908451906335fdcccd60e21b82523390820152fd5b8280fd5b849134610321576020366003190112610321573563ffffffff60e01b811680910361032157602092506385572ffb60e01b8114908115610367575b5015158152f35b6301ffc9a760e01b14905083610360565b6040519190601f01601f1916820167ffffffffffffffff81118382101761039e57604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161039e57601f01601f191660200190565b81601f8201121561040d578035906103ea610204836103b4565b928284526020838301011161040d57816000926020809301838601378301015290565b600080fd5b60005b8381106104255750506000910152565b818101518382015260200161041556fea264697066735822122017dd9f90ea2f667619bd417745b90c618e65f897f9638001e304a9959e24c52164736f6c634300081700330000000000000000000000000bf3de8c5d3e8a2b34d2beeb17abfcebaf363a59","gas":"304267","from":"0xaF7E68bCb2Fc7295492A00177f14F59B92814e70","transactionSettings":{"chainId":11155111,"nonce":"104","baseFee":"1916855887","priorityFee":"1000000000"},"salt":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000PINGPONG","artifact":{"abi":[{"type":"constructor","inputs":[{"name":"_router","type":"address","internalType":"address"}],"stateMutability":"nonpayable"},{"type":"function","name":"ccipReceive","inputs":[{"name":"message","type":"tuple","internalType":"struct Client.Any2EVMMessage","components":[{"name":"messageId","type":"bytes32","internalType":"bytes32"},{"name":"sourceChainSelector","type":"uint64","internalType":"uint64"},{"name":"sender","type":"bytes","internalType":"bytes"},{"name":"data","type":"bytes","internalType":"bytes"},{"name":"destTokenAmounts","type":"tuple[]","internalType":"struct Client.EVMTokenAmount[]","components":[{"name":"token","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}]}]}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getRouter","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"supportsInterface","inputs":[{"name":"interfaceId","type":"bytes4","internalType":"bytes4"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"pure"},{"type":"event","name":"Pong","inputs":[{"name":"info","type":"string","indexed":false,"internalType":"string"}],"anonymous":false},{"type":"error","name":"InvalidRouter","inputs":[{"name":"router","type":"address","internalType":"address"}]}],"bytecode":"0x60a03461008e57601f61051538819003918201601f19168301916001600160401b038311848410176100935780849260209460405283398101031261008e57516001600160a01b03811680820361008e57156100755760805260405161046b90816100aa82396080518181816059015260cf0152f35b6040516335fdcccd60e21b815260006004820152602490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060408181526004918236101561001657600080fd5b600092833560e01c91826301ffc9a7146103255750816385572ffb1461008c575063b0f479a11461004657600080fd5b34610088578160031936011261008857517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b91905034610321576020906003199282843601126102795780359067ffffffffffffffff948583116102755760a090833603011261027d576001600160a01b03907f00000000000000000000000000000000000000000000000000000000000000008216330361030a5783519060a08201828110888211176102f7578552838101358252602492602485013588811681036102ef578784015260448501358881116102ef57610140908336918801016103d0565b8684015260648501358881116102ef5761015f908336918801016103d0565b94606084019586526084810135908982116102f3570191366023840112156102ef5780830135918983116102dc5761019b898460051b01610378565b9560248a88868152019460061b860101943686116102d857602401935b858510610281575050505050506080015251928351840193838181870196031261027d578381015191821161027d570183603f82011215610279578281015193610209610204866103b4565b610378565b9185835284830191848783010111610275577fa7b4f710e7636ed7b4f98085b7004cd898d5cafa9d5d3e19e7a435283d3a2c4d9582856102499301610412565b6102658351948593818552519283809286015285850190610412565b601f01601f19168101030190a180f35b8680fd5b8480fd5b8580fd5b89853603126102d857895190818b018d8111838210176102c6578b5285359084821682036102c257828d928d945282880135838201528152019401936101b8565b8e80fd5b634e487b7160e01b8f5260418652838ffd5b8c80fd5b634e487b7160e01b8b526041825260248bfd5b8980fd5b8a80fd5b634e487b7160e01b895260418252602489fd5b6024908451906335fdcccd60e21b82523390820152fd5b8280fd5b849134610321576020366003190112610321573563ffffffff60e01b811680910361032157602092506385572ffb60e01b8114908115610367575b5015158152f35b6301ffc9a760e01b14905083610360565b6040519190601f01601f1916820167ffffffffffffffff81118382101761039e57604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161039e57601f01601f191660200190565b81601f8201121561040d578035906103ea610204836103b4565b928284526020838301011161040d57816000926020809301838601378301015290565b600080fd5b60005b8381106104255750506000910152565b818101518382015260200161041556fea264697066735822122017dd9f90ea2f667619bd417745b90c618e65f897f9638001e304a9959e24c52164736f6c63430008170033","compiler":{"version":"v0.8.23+commit.f704f362"},"contractName":"src/CrossChainGovernanceReceiver.sol:CrossChainGovernanceReceiver","license":"MIT","jsonDescription":{"language":"Solidity","sources":{"lib/ccip/CCIPReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"./IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"./Client.sol\";\n\nimport {IERC165} from \"../openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n    address internal immutable i_router;\n\n    constructor(address router) {\n        if (router == address(0)) revert InvalidRouter(address(0));\n        i_router = router;\n    }\n\n    /// @notice IERC165 supports an interfaceId\n    /// @param interfaceId The interfaceId to check\n    /// @return true if the interfaceId is supported\n    /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n    /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n    /// This allows CCIP to check if ccipReceive is available before calling it.\n    /// If this returns false or reverts, only tokens are transferred to the receiver.\n    /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n    /// Additionally, if the receiver address does not have code associated with\n    /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n        return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    /// @inheritdoc IAny2EVMMessageReceiver\n    function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n        _ccipReceive(message);\n    }\n\n    /// @notice Override this function in your implementation.\n    /// @param message Any2EVMMessage\n    function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n    /////////////////////////////////////////////////////////////////////\n    // Plumbing\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the current router\n    /// @return i_router address\n    function getRouter() public view returns (address) {\n        return address(i_router);\n    }\n\n    error InvalidRouter(address router);\n\n    /// @dev only calls from the set router are accepted.\n    modifier onlyRouter() {\n        if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\n        _;\n    }\n}\n"},"lib/ccip/Client.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n    /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n    struct EVMTokenAmount {\n        address token; // token address on the local chain.\n        uint256 amount; // Amount of tokens.\n    }\n\n    struct Any2EVMMessage {\n        bytes32 messageId; // MessageId corresponding to ccipSend on source.\n        uint64 sourceChainSelector; // Source chain selector.\n        bytes sender; // abi.decode(sender) if coming from an EVM chain.\n        bytes data; // payload sent in original message.\n        EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n    }\n\n    // If extraArgs is empty bytes, the default is 200k gas limit.\n    struct EVM2AnyMessage {\n        bytes receiver; // abi.encode(receiver address) for dest EVM chains\n        bytes data; // Data payload\n        EVMTokenAmount[] tokenAmounts; // Token transfers\n        address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n        bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n    }\n\n    // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n    bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n    struct EVMExtraArgsV1 {\n        uint256 gasLimit;\n    }\n\n    function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n        return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n    }\n}\n"},"lib/ccip/IAny2EVMMessageReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"./Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n    /// @notice Called by the Router to deliver a message.\n    /// If this reverts, any token transfers also revert. The message\n    /// will move to a FAILED state and become available for manual execution.\n    /// @param message CCIP Message\n    /// @dev Note ensure you check the msg.sender is the OffRampRouter\n    function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"src/CrossChainGovernanceReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver, Client} from \"../lib/ccip/CCIPReceiver.sol\";\n\ncontract CrossChainGovernanceReceiver is CCIPReceiver {\n    event Pong(string info);\n\n    constructor(address _router) CCIPReceiver(_router) {}\n\n    /// @inheritdoc CCIPReceiver\n    function _ccipReceive(Client.Any2EVMMessage memory message) internal override {\n        (string memory info) = abi.decode(message.data, (string));\n        emit Pong(info);\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"remappings":["@layerzerolabs/lz-evm-protocol-v2/contracts/=lib/LayerZero-v2/protocol/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ccip/=lib/ccip/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"viaIR":true},"evmVersion":"paris","metadata":{"useLiteralContent":true}}},"source":"/home/plopmenz/crosschain-governance","submitted":{"transactionHash":"0xbe4e1e367203faa6a07d3871c208bd374354f460d09332020a96c0ec4f3abe91","date":"2024-03-14T21:20:29.490Z"}}